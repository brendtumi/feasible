import { access, constants, readFile, unlink, writeFile } from 'node:fs/promises';
import { dirname, extname } from 'node:path';
import { createHash } from 'node:crypto';

import yaml, { dump } from 'js-yaml';
import JSON5 from 'json5';
import Debug from 'debug';
import execShPromise from 'exec-sh';
import { globby } from 'globby';
import inquirer from 'inquirer';
import get from 'lodash.get';
import { makeDirectory } from 'make-dir';
import ivm from 'isolated-vm';
import { v4 as uuidv4 } from 'uuid';

import { logger } from './logger.js';

export const debug = Debug('feasible');
const regexVar = /\${(?<var>[a-zA-Z0-9-_.]+)(\.val)?(\.name)?}/gi;

export async function isAccessible (path) {
  return access(path, constants.F_OK | constants.R_OK);
}

export async function read (path) {
  await isAccessible(path);
  return readFile(path, { encoding: 'utf-8' });
}

function parseJson (content) {
  return JSON.parse(content);
}

function parseYaml (content) {
  return yaml.load(content);
}

function parseJson5 (content) {
  return JSON5.parse(content);
}

function parseContentByType (content, ext) {
  switch (ext) {
    case '.json':
      return parseJson(content);
    case '.json5':
      return parseJson5(content);
    case '.lock':
    case '.yaml':
    case '.yml':
      return parseYaml(content);
    default:
      throw new Error(`Unsupported file extension "${ext}"`);
  }
}

export async function readAsObject (path) {
  const content = await read(path);
  return parseContentByType(content, extname(path));
}

function checksum (obj, algorithm, encoding) {
  return createHash(algorithm || 'md5')
    .update(JSON.stringify(obj), 'utf-8')
    .digest(encoding || 'hex');
}

export async function write (object, path, version) {
  const dumped = yaml.dump({
    ...object,
    checksum: {
      file: path,
      hash: checksum(object),
      version
    }
  }, {});
  const content = `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# feasible lock file, version ${version || '#'}

${dumped}`;

  return writeFile(path, content, { encoding: 'utf-8' });
}

export function exit (code) {
  if (Number(code) > 0) {
    logger.error(`Exiting with error code: ${code}`);
    process.exit(Number(code));
  } else {
    logger.info('Done...');
    process.exit(Number(code) || 0);
  }
}

export async function parseConfigFile (config, url) {
  let obj;
  if (url) {
    try {
      const content = await fetch(url).then((res) => res.text());
      const fileType = extname(new URL(url).pathname);
      obj = parseContentByType(content, fileType);
      return { checksum: checksum(obj), configuration: obj, file: url };
    } catch (e) {
      logger.error(e);
      throw new Error(`Config file not found! "${config}", "${url}"`);
    }
  } else {
    const [firstMatch] = await globby(config);
    if (firstMatch) {
      obj = await readAsObject(firstMatch);
      return { checksum: checksum(obj), configuration: obj, file: firstMatch };
    } else {
      logger.error(`No file matches with ${config}`);
      throw new Error(`No file matches with ${config}`);
    }
  }
}

export async function unlinkFile (path) {
  try {
    await isAccessible(path);
    return unlink(path);
  } catch (e) {
    debug("File is not accessible, don't run unlink");
  }
}

export function isBase64 (str) {
  return Buffer.from(str, 'base64').toString('base64') === str;
}

function escapeRegExp (string) {
  return string.replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}

function replaceAll (str, find, replace) {
  return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);
}

function replaceVariableInString (file, vars, separator) {
  if (!regexVar.test(file)) {
    return file;
  }
  const uniqueVariables = file.match(regexVar).filter((v, i, a) => a.indexOf(v) === i);
  for (const uniqueVariable of uniqueVariables) {
    const variable = uniqueVariable.replace(regexVar, '$1');
    if (variable === undefined) {
      throw new Error('');
    } else if (variable.includes('.val')) {
      const escape = variable.includes('.unescape');
      const genVar = vars[variable.replace('.val', '').replace('.unescape', '')];
      if (genVar === undefined) {
        throw new Error(`Variable "${variable} not found in the variables list`);
      }
      file = replaceAll(file, uniqueVariable, genVar.toString().includes(' ') && !escape ? `'${genVar}'` : genVar);
    } else if (variable.endsWith('.name') && variable.replace('.name', '') in vars) {
      file = replaceAll(file, uniqueVariable, variable.replace('.name', ''));
    } else if (variable.endsWith('.env') && variable.replace('.env', '') in process.env) {
      file = replaceAll(file, uniqueVariable, process.env[variable.replace('.env', '')]);
    } else {
      if (vars[variable] === undefined) {
        throw new Error(`Variable "${variable} not found in the variables list`);
      }
      const genVar = vars[variable].toString().includes(' ') ? `'${vars[variable]}'` : vars[variable];
      file = replaceAll(file, uniqueVariable, [variable, genVar].join(separator));
    }
  }
  return file;
}

export async function execHook (hooks, configuration, variables, separator) {
  const hks = typeof hooks === 'string' ? [hooks] : hooks;
  for (const hook of hks) {
    debug(`Execute hook ${hook}`);
    if (
      configuration &&
      'actions' in configuration &&
      hook in configuration.actions &&
      configuration.actions[hook].length
    ) {
      for (let i = 0; i < configuration.actions[hook].length; i++) {
        const actionElement = configuration.actions[hook][i];
        let out;
        try {
          out = await execShPromise.promise(replaceVariableInString(actionElement, variables, separator), true);
        } catch (e) {
          logger.error(`action:${hook}#${i + 1}: ${e.stderr}`);
          throw Error(e);
        }
        if (out.stderr.length > 0) {
          logger.error(`action:${hook}#${i + 1}: ${out.stderr}`);
        } else {
          logger.info(`action:${hook}#${i + 1}: ${out.stdout}`);
        }
      }
    }
  }
}

export async function promptUI (configuration, lock) {
  debug('promptUI');
  const prompts = Object.entries(configuration.variables).map(
    ([name, { question, type = 'input', options, initial }]) => {
      if (type === 'base64' || type === 'base64()') {
        debug(`promptUI, input: ${name}`);
        return {
          type: 'input',
          name,
          message: question,
          choices: options,
          default: lock.getVariableValue(name, initial, options),
          filter: (val) => {
            return isBase64(val) ? val : Buffer.from(val).toString('base64');
          }
        };
      }
      if (type === 'random' || type === 'random()' || initial === 'random()') {
        debug(`promptUI, random: ${name}`);
        return {
          type: 'input',
          name,
          message: question,
          default: lock.getVariableValue(name, uuidv4(), options)
        };
      }
      debug(`promptUI, default: ${name}`);
      return {
        type: options && Array.isArray(options) && options.length ? 'list' : type === 'string' ? 'input' : type,
        name,
        message: question,
        choices: options,
        default: lock.getVariableValue(name, initial, options)
      };
    }
  );
  return inquirer.prompt(prompts);
}

export async function resolveVariables (variables, defaults, { separator }) {
  debug('resolveVariables');
  const resolved = {};
  for (const [name, value] of Object.entries(defaults)) {
    if (typeof value === 'object' && value.type === 'bash') {
      const command = replaceVariableInString(value.command, { ...variables, ...resolved }, separator);

      const out = await execShPromise.promise(command, true);
      let parsed;
      if (out.stderr.length > 0) {
        logger.error(`Resolve variable "${name}": ${out.stderr}`);
        parsed = out.stderr.toString().trim();
      } else {
        logger.info(`Resolving variable "${name}"`);
        parsed = out.stdout.toString().trim();
      }
      parsed = 'output' in value && value.output === 'json' ? JSON.parse(parsed) : parsed;
      resolved[name] = 'query' in value ? get(parsed, value.query) : parsed;

      logger.success(`"${name}" resolved to: ${resolved[name]}`);
    } else {
      resolved[name] = value;
    }
  }
  return { ...variables, ...resolved };
}

function objectFileType (file, variables) {
  if (file.type === 'json') {
    return JSON.stringify(
      file.variables.reduce((a, c) => {
        if (typeof c === 'string') {
          a[c] = variables[c];
        } else {
          a[c[0]] = variables[c[1]];
        }
        return a;
      }, {})
    );
  }
  if (file.type === 'yaml') {
    return dump(
      file.variables.reduce((a, c) => {
        if (typeof c === 'string') {
          a[c] = variables[c];
        } else {
          a[c[0]] = variables[c[1]];
        }
        return a;
      }, {})
    );
  }
  if (file.type === 'env') {
    return replaceVariableInString(
      file.variables
        .map((x) => {
          return typeof x === 'string' ? '${' + x + '}' : x[0] + '=${' + x[1] + '.val}';
        })
        .join('\n'),
      variables,
      '='
    );
  }
}

export async function executeFiles (configuration, variables, lock, { separator }) {
  debug('executeFiles');
  const paths = [];
  const generatedContents = {};
  const sandboxVariables = Object.fromEntries(Object.entries(variables).map(([k, v]) => [`$${k}`, v]));
  const isolate = new ivm.Isolate({ memoryLimit: 128 });
  const context = await isolate.createContext();
  for (const key in sandboxVariables) {
    await context.global.set(key, new ivm.ExternalCopy(sandboxVariables[key]).copyInto());
  }

  if (configuration && 'files' in configuration) {
    for (const [path, file] of Object.entries(configuration.files)) {
      debug(`Execute file: ${path}`);
      const sandboxContents = Object.fromEntries(
        Object.entries(generatedContents).map(([k, v]) => [k.replace(/[^a-z0-9]+/gi, '_'), v])
      );

      if (typeof file === 'string') {
        generatedContents[path] = replaceVariableInString(file, { ...variables, ...sandboxContents }, separator);
      } else if (typeof file === 'object' && 'type' in file && 'variables' in file) {
        generatedContents[path] = objectFileType(file, { ...variables, ...sandboxContents });
      } else if (
        typeof file === 'object' &&
        'condition' in file &&
        ('content' in file || ('success' in file && 'fail' in file))
      ) {
        const contextVariables = { ...Object.fromEntries(Object.entries(sandboxContents).map(([k, v]) => [`$${k}`, v])) };
        for (const key in contextVariables) {
          await context.global.set(key, new ivm.ExternalCopy(contextVariables[key]).copyInto());
        }

        let isTruthy = false;
        try {
          isTruthy = !!(await context.eval(file.condition));
        } catch (e) {
          logger.warn(`Custom condition on "${path}" throws an error: ${e.message}`);
        }
        if (isTruthy) {
          if ('success' in file && 'fail' in file) {
            generatedContents[path] =
              typeof file.success === 'object' && 'type' in file.success && 'variables' in file.success
                ? objectFileType(file.success, { ...variables, ...sandboxContents })
                : replaceVariableInString(file.success, { ...variables, ...sandboxContents }, separator);
          } else {
            generatedContents[path] =
              typeof file.content === 'object' && 'type' in file.content && 'variables' in file.content
                ? objectFileType(file.content, { ...variables, ...sandboxContents })
                : replaceVariableInString(file.content, { ...variables, ...sandboxContents }, separator);
          }
        } else {
          if ('success' in file && 'fail' in file) {
            generatedContents[path] =
              typeof file.fail === 'object' && 'type' in file.fail && 'variables' in file.fail
                ? objectFileType(file.fail, { ...variables, ...sandboxContents })
                : replaceVariableInString(file.fail, { ...variables, ...sandboxContents }, separator);
          } else {
            logger.aligned(path, 'Condition not met.', '.', 'warn');
          }
        }
      } else {
        logger.aligned(path, 'Unrecognizable file type', '.', 'warn');
      }
    }
  }
  for (const [path, generated] of Object.entries(generatedContents)) {
    debug(`makeDirectory: ${dirname(path)}`);
    await makeDirectory(dirname(path));
    debug(`writeFile: ${path}`);
    await writeFile(path, generated.toString(), { encoding: 'utf-8' });
    debug('Done');
    paths.push(path);
    logger.aligned(path, 'File Generated.');
  }
  return paths;
}
