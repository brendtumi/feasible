const { accessSync, existsSync, readFileSync, constants, writeFileSync } = require('fs');
const { load, dump } = require('js-yaml');
const log = require('./logs')();

class Lock {
  lockFilePath;
  hasPrevious = false;
  previous = {
    checksum: { file: null, hash: null, version: null },
    variables: {},
    files: {},
  };

  current = {
    checksum: { file: '', hash: '', version: '' },
    variables: {},
    files: [],
  };

  constructor(lockFile, lockFileVersion, configurationFilePath, configurationHash) {
    this.lockFilePath = lockFile;
    this.current.checksum.file = configurationFilePath;
    this.current.checksum.hash = configurationHash;
    this.current.checksum.version = lockFileVersion;
    this.readLockFile();
  }

  readLockFile() {
    if (existsSync(this.lockFilePath)) {
      try {
        accessSync(this.lockFilePath, constants.R_OK | constants.W_OK);
        this.previous = load(readFileSync(this.lockFilePath, { encoding: 'utf-8' }));
        this.hasPrevious = true;
      } catch {
        log.warn('No lock file found or accessible');
      }
    } else {
      log.info(`${this.lockFilePath} is not found but will be created.`);
    }
  }

  /**
   * Is lock file need to be updated?
   * @returns {boolean}
   */
  isFileNeedUpdate() {
    if (!this.hasPrevious) {
      return true;
    } else if (!this.previous.checksum.version || this.current.checksum.version !== this.previous.checksum.version) {
      return true;
    } else if (this.previous.checksum.hash !== this.current.checksum.hash) {
      return true;
    } else if (this.previous.checksum.file !== this.current.checksum.file) {
      return true;
    }
    return false;
  }

  getVariableValue(name, initial, options) {
    let variable;
    if (name in this.current.variables) {
      variable = this.current.variables[name];
    } else if (name in this.previous.variables) {
      variable = this.previous.variables[name];
    } else {
      variable = initial;
    }
    if (options && options.includes(variable)) {
      return options.indexOf(variable);
    }
    return variable;
  }

  getAllPreviousVariables() {
    return this.previous.variables;
  }

  setVariables(list) {
    this.current.variables = list;
  }

  cleanupList() {
    return this.previous.files;
  }

  setFileList(files) {
    this.current.files = files;
  }

  export(checksum, variables, files, version, lockFilePath) {
    const content = dump({
      checksum: checksum,
      variables: variables,
      files: files,
    });
    writeFileSync(
      lockFilePath || this.lockFilePath,
      `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# feasible lock file, version ${version || '#'}

${content}`,
    );
  }

  save() {
    this.export(this.current.checksum, this.current.variables, this.current.files, this.current.checksum.version);
    log.success('Lock file updated!');
  }

  backup() {
    this.export(
      this.current.checksum,
      this.current.variables,
      this.current.files,
      this.current.checksum.version,
      `${this.lockFilePath}.backup`,
    );
    log.info('Lock file backup saved.');
  }

  restore() {
    this.backup();
    this.export(this.previous.checksum, this.previous.variables, this.previous.files, this.previous.checksum.version);
    log.success('Lock file restored!');
  }
}

module.exports = Lock;
